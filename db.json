[{"title":"vue-router","url":"/2023/08/15/vue-router/","content":"vue-router\n\nvue的一个插件库(想到了vuex),专门用来实现SPA\n\n关于SPA\n\n![image-20230801153443299](https://cdn.jsdelivr.net/gh/Ggboy001/images/img/202308151204103.png)\n\nrouter(路由器,管理多个路由)\n\nroute(路由,一组key-value,就是路径-组件)\n\n#### vue-router使用\n\n1. 安装\n2. vue使用\n3. 创建router文件夹\n4. 实例化路由器并传入路由配置并暴露\n5. 引入到main中并传入router\n\n使用router-link实现路由切换\n\n使用router-view指定展示位置\n\n注意点：\n\n路由组件放在pages，一般组件放在components\n\n![image-20230802161746406](https://cdn.jsdelivr.net/gh/Ggboy001/images/img/202308151204105.png)\n\n#### 嵌套路由\n\n注意就是children配置里面的path不需要加/，然后routerlink中需要to父级＋子级路径才能匹配到\n\n```vue\n<router-link class=\"list-group-item active\" to=\"/home/mes\">Message</router-link>\n```\n\n#### 路由传参\n\n1. query传参(路径上就是有?)\n\n携带query参数,to的两种写法:\n\n- 字符串\n\n```js\n<router-link :to=\"`/home/message?id=${m.id}&title=${m.title}`\"></router-link >\n```\n\n- 对象\n\n```js\n<router-link :to=\"{\npath:'/home/message/detail'\nquery:{\nid:m.id,\ntitle:m.title\n}\n}\"></router-link >\n```\n\n#### 命名路由\n\n就是路由注册的时候加一个name属性，在路径比较长的时候可以直接呼唤名字\n\n```js\n<router-link :to=\"{\npath:'/home/message/detail'----替换成\nname:'xiangqing'\nquery:{\nid:m.id,\ntitle:m.title\n}\n}\"></router-link >\n```\n\n2. params(路径/)传参\n\n配置路由的path路径时:\n\n```js\npath:'/home/message/:id/:title'(需要有占位符)\n```\n\n注意:在对象方式传参时必须使用name去寻找路由而不是path\n\n了解:\n\n\\- 获取数据:使用 query 参数\n\\- 编辑数据:使用 params 参数\n\n#### 路由的props配置\n\n第一种写法:  true时,会把params传给该组件的所有参数以props形式传给该组件\n\n```js\nprops:true\n```\n\n第二种写法: \n\n```js\nprops($route){\n  return {\n        id:$route.query.id,\n     title:$route.params.title\n  }\n}\n解构赋值更推荐这种\nprops({query:{id,title}}){\n  return {\n       id,title\n  }\n}\n```\n\nprops是用来将组件接收到的参数以props的形式给该组件(需要在组件中用props接收)\n\n#### router-link的replace属性\n\n添加这个属性后,跳转链接时把历史浏览记录的栈顶给修改成当前跳转链接\n\n\\- 登录/退出登录后跳转首页\n\n#### 编程式路由导航\n\n需求:不能用router-link了,需要点击按钮后或者页面加载完成跳转(和事件有关)\n\n```js\ntojioalian(id) {\n this.$router.push({\n                path: '/jiaolian',\n                query: {\n                    id: id\n                }\n            })\n        },\n```\n\n$router上除了push,还有replace,back,forward,go\n\n#### <keep-alive include=\"组件名字\">\n\n用于缓存不展示的路由组件,让其不被销毁\n\n- 缓存表单填写过的信息\n- 缓存之前看到的位置\n\n注意这个 `<keep-alive>` 要求被切换到的组件都有自己的名字\n\n#### 路由组件特有的生命周期钩子\n\n---actived（激活），deactived（失活）\n\n#### 路由守卫\n\n1.全局守卫\n\n全局前置路由守卫\n\n```js\nrouter.beforeEach((to:obj,from:obj,next:f)=>{\n执行路由判断逻辑根据to中的属性(name或path)  or\n用meta.isAuth来判断(需要提前在route中配置meta对象)\n})\n```\n\n(初始化的时候、在每一次路由切换之前被调用)\n\n- 前置守卫主要负责对路由进行访问控制,包括鉴权(鉴定用户的可以使用的权限)、权限、频率限制等场景。 \n\n​    全局后置路由守卫\n\n```js\nrouter.afterEach((to,from)=>{})\n```\n\n- 后置路由守卫主要适合处理页面加载后需要执行的一些逻辑,如埋点、标题、鉴权、数据加载等。 \n\n2.独享路由守卫\n\n```js\nbeforeEnter((to,from,next)=>{})\n```\n\n3.组件路由守卫\n\n```js\nbeforeRouteEnter((to,from,next)=>{})\n```\n\n```js\nbeforeRouteLeave((to,from,next)=>{})\n```\n\n\n\n小认知:\n\n脚手架打包出来的项目必须要部署才能运行\n\n路由器的有个配置是mode(hash和history),区别就是在url上更改会不会发送网络请求去请求资源\n\n组件库仅仅就是在用到的时候翻看文档就可以,千万别耗费时间."},{"title":"vuex基础知识","url":"/2023/08/15/vuex基础学习/","content":"\n## vuex\n\n概念：专门在vue中实现集中式状态管理的一个vue插件，对多个组件的共享状态进行集中式管理的。\n\n一个状态需要被共享就可以用vuex\n\n![image-20230731105920141](https://cdn.jsdelivr.net/gh/Ggboy001/images/img/202308151154256.png)\n\n看这张图（一定要细致，细致之后的学习会很舒服）\n\n1. 首先，在组件里面调用dispatch接口，传参（进行的操作，和什么数值操作）\n2. vuex的actions里面有一个键值对，是有关这个操作的函数（函数里面需要手动调用commit接口）\n3. 在mutations里面有个键值对是用来根据要做的操作修改state中的值\n4. 最终渲染到页面\n\nactions真正的作用是如果要进行的操作需要向服务器端获取数值，就可以在这个actions中发送ajax请求获取这个数值\n\n若知道操作和数值，可以直接在组件调用commit接口去直接到达mutations\n\n图中没有展现的是actions，mutations，state都是需要store进行管理的，也就是调用接口需要store.dispatch\n\n#### vuex的初始配置\n\n1. 安装插件\n2. Vue.use（只有使用了，vue传入store配置vue才认）\n3. 创建store（需要传入配置项）\n4. vm传入store配置项\n\n#### vuex的使用\n\n- 把共享数据放入state中\n- 插值语法可直接访问到$store，可以拿到state中的值\n- dispatch中第一个参数是进行的操作，写在组件的函数中\n- commit中第一个参数是大写的操作，显得牛逼，写在actions中的操作函数中\n- 小写的操作函数中第一个参数是context，大写的操作函数第一个参数是state\n\n再度完善，写的更规范些：\n\n- 有业务逻辑，把业务逻辑放在actions中\n- 无业务逻辑，且已知数值，直接在组件的方法中调用commit接口\n\n另外记一个store中的配置项，getters，和计算属性类似，也是靠return拿到值，（函数参数是state）\n\n\n\n#### Vuex精简代码\n\n1. 借助vuex中的mapState，mapGetters去映射state，getters，\n\n-    传入对象（改名用这个，注意值为字符串）\n\n-    传入数组（简写用这个）![image-20230731220702474](https://cdn.jsdelivr.net/gh/Ggboy001/images/img/202308151154258.png)\n\n2. 借助vuex中的mapMutations，mapActions去生成对应的方法，前者方法中会调用commit与mutations对话，后者方法中会调用dispatch与actions对话\n\n传入对象{函数名：'操作大写'}\n\n备注：需要注意模板中绑定事件需要传入要与什么数值操作，否则就是传入event\n\n#### Vuex模块化+命名空间\n\nQ:要管理的共享数据会非常多，导致mutations等等配置特别臃肿，且不适合维护，那应该怎么办呐？\n\nA:将这些配置按与实现什么业务相关进行分类\n\n![image-20230731231001763](https://cdn.jsdelivr.net/gh/Ggboy001/images/img/202308151154259.png)\n\n1. 模块化之后怎么在组件中简写形式拿到数据呐？\n\n就需要用到namespaced配置并且在四个map...中的第一个参数指定是模块化之后的哪一个\n\n总结：(学了将近1小时,又看视频又敲代码,就学这么点东西,就是因为创建正确的联系,如果在听的时候不那么注重细节,而把重点放在老师要讲的联系上,会不会更好)\n\n- 在不同的业务逻辑下将store模块化\n- 开启namespaced并且map...中第一个参数指定是哪一个模块\n\n2. 若不采用简写形式呐?(也就是自己去从state,getters中拿值,自己调用dispatch,commit)\n\n拿state中的值时需要指定是哪一个模块\n\n拿getters中的值时不用指定哪一个模块,用getters[countAbout/firstname]\n\ndispatch和commit传递第一个参数时都要用在操作名前面拼接'模块/'\n\n![image-20230801115953040](https://cdn.jsdelivr.net/gh/Ggboy001/images/img/202308151154260.png)\n\n![image-20230801145617700](https://cdn.jsdelivr.net/gh/Ggboy001/images/img/202308151153250.png)\n\nvuex的规范:\n\nsrc写一个store文件,里面根据业务区分出来不同的store,然后暴露出去,在index中引入并写入modules中\n\n\n\n真的容易忘,虽然一天学完了,但是过了几天之后发现真的生疏,非常多的之前建立的联系都i想不起来了,很耗费脑子.看来还是要尽可能快的学完,然后重在做项目实践."},{"title":"first blog记录","url":"/2023/06/16/firstblog_createblogrecord/","content":"\n## build my blog\n\n时间:2小时+2小时+1.5小时+4.5小时+1小时+2+3\n\n### 环境安装（基本都有）\n\n- node\n\n- git\n\n- typora\n\n- github账号\n\n  > 创建仓库（注意命名，用户名+github.io）\n\n- 科学上网\n\n- 安装Hexo(高效的静态站点生成框架,基于node.js)\n\n  <!--hexo init出现了问题,应该是因为hexo init时文件里面不是空的.删除一下就好了-->\n\n### 连接github和本地\n\n- git bash中生成密钥\n- github上注册密钥\n- 修改_config.yml文件(博客的配置文件,可以修改与博客相关的各种信息)（修改一下deploy部署这个page就可以实现部署到github page上，就可以实现别人访问到我的网页）\n- 安装自动部署发布工具hexo-deployer-git\n\n### 网址的简单美化\n\n先试一下hexo的主题\n\n但出现了一个问题：在clone主题的时候\n\n`Cloning into 'hexo-theme-matery'...\nfatal: unable to access 'https://github.com/blinkfox/hexo-theme-matery.git/':iled to connect to github.com port 443: Timed out`\n\n方法：更改代理端口（肯定要开代理的）\n\n```\ngit config --global http.proxy http://127.0.0.1:7890\n```\n\n\n\n### 网页\n\n网页调整\n\n- 修改原始默认主题为hexo-theme-matery接着更改_config.yml中的相关配置\n\n- 创建几个必须的页面(categories,tags,about)\n\n- 配置菜单导航(基本上和配置有关的,优先考虑在_config.yml中添加)(修改配置需要注意缩进的)(配置不了,不知道什么原因)\n\n  > 竟然有个默认配置可以修改提交代码到哪一个分支，main(卡这里好一会)\n\n网页进一步美化\n\n挑一挑可用的主题\n\n\n\n### 优化\n\n- 域名（域名备案）\n\n- 图床\n\n- 服务器\n\n  \n\n [详细了解](https://zblogs.top/how-to-build-a-personal-blog-site/)\n\n\n\nnote:又拍云cdn之后可以用于提高网站加载速度\n\n\n\n## 拓展了解\n\n### 静态博客和动态博客\n\n- 静态博客\n\n  > - html代码生成后,页面的内容和显示效果就基本不会变化\n  > - 不会有太多用户交互(本来就是给自己写文章的,也不需要有太多交互效果)\n  > - 就几个页面,要求不高,github page或低配服务器都可以\n  > - 纯代码小白不推荐使用hexo+github创建,较麻烦,且耗时\n\n- 动态博客\n\n> - 可以随时间,数据库操作的结果的改变而变化\n> - 可以设计用户交互,着重用户体验感,这也就不是个人博客了,更偏向于用户使用的网站\n> - 服务器根据个人需求\n> - 可用wordpress等创建,简单易上手\n\n\n\n我感觉写博客可以帮助我更好的表达自己,尤其是要站在别人的角度.自己经常性的就是仅仅让自己懂,但是别人并不理解.\n\n输入我想输入的,输出我可以输出的.\n\n明天: 3小时\n更改为butterfly主题\n\n找了一个小时10分钟，觉得还是不需要花时间去找了。嗯就这样。先用着这个基于butterfly的anzhiyu主题吧。然后再根据文档找找自己需要的功能。\n\n美化根据文档其实就是时间问题.现在先大致这样.等之后有时间可以再更改\n\n#### questions：\n\n- nav没有显示出来\n- 文章封面设置显示不出来并且报错(要注意修改的配置在什么文件)\n- footer上班摸鱼去不了\n\n- 线上输入域名打开排版很乱，刚开始以为是没有CDN或者github pages的问题，或者是主题配置的问题，或者是控制台报错的问题，在这卡了有两天时间，但没有浪费，（就着问题我优化了双线部署，也搭建了图床，也了解到控制台一些报错信息的原因。）。最后解决问题的方式竟然是偶尔打开一个博主的创建博客的教程，让我看到了hexo clean，尝试一下，然后就可以了。这么说，排错有时候真的很靠运气啊。\n\n> ```  hexo clean```\n>\n> 清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)。\n>\n> 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n\n\n\n之后的兴趣拓展点:(当然也要注意时间四象限)\n\n- 主题拓展找找自己喜欢的\n- 图床\n- 加速网站访问速度,cdn(Content Delivery Network,,将内容缓存在终端用户附近,加速了网站的访问——用户与内容之间的物理距离缩短，用户的等待时间也得以缩短)\n\n\n\n### 写博客可以写的属于自己的结构\n\n- 首先目的,知识点的用处以及为什么\n- 其次不依附所写内容的灵感感悟\n- 最后是拓展点\n\nMaterial Design\n\n注重卡片式设计、纸张的模拟、使用了强烈对比色彩的设计风格\n\ntips：\n\n写代码块的语法```         代码```\n\n\n\n使用hexo s 启动本地服务后，如果修改了配置或者文章内容，需要停止服务后重新启动才能生效。这样，在调试或写文章阶段非常不方便，可以使用下面命令，以debug的方式启动，这样每次修改后就无需重启服务了。\n\n> $ hexo s –debug（。。。不是我想要的功能，这就是博客的不严谨的地方，但应该有些用处，之后了解一下）\n\n重要的\\觉得自己忘了有损失的知识点记录下来,其余的就忘记那也改变不了.\n\n## 优化blog网站\n\n### 部署github仓库到vercel\n\n- 首先就是github登录到vercel\n- 然后import仓库就行\n- 再稍微调节一下设置参数\n- 所以我的博客现在是双线部署\n\n双线部署的优点：\n\n- 避免一个出现故障就访问不了\n- 访问请求分发到不同的服务器，提高博客整体性能\n\ngithub pages是不支持 实时部署的，\n\nvercel支持\n\n问题： \n\n``` net::ERR_BLOCKED_BY_CLIENT```\n\n浏览器防广告的插件的问题\n\n![image-20230619002418850](https://cdn.jsdelivr.net/gh/Ggboy001/images/img/image-20230619002418850.png)\n\n### 图床\n\ngithub+typora+jsdeliver实现\n\njsdelivr是首个打通国内与海外的免费CDN服务\n\n- github创建放图片的仓库\n- github创建token用于picgo图床配置填写以可以向仓库写入图片\n- 填写picgo图床配置注意按格式填写,自定义域名用到jsdelivr\n\n\n\n拓展:\n\n- 之后可以详细了解下jsdelivr还可以做什么\n\n- hexo的指令\n\n\n\n"}]